---
layout: post
title: "백준 2636번"
date: 2025-12-14 14:20:00 +0900
categories: [코테]
tags: [graph, bfs]
math: true
---

## 문제
{% include link-preview.html url="https://www.acmicpc.net/problem/2636" title="백준 2636번 문제" %}

## 풀이

### 1. 초기 접근: 치즈 주변 탐색
처음에는 단순히 2중 `for`문을 돌면서 치즈(`1`)를 찾고, 그 주변에 공기(`0`)가 있는지 확인하려고 했다.

**문제점:**
*   이 문제의 까다로운 점은 **공기**가 두 종류로 나뉜다는 것이다.
    *   **외부 공기:** 치즈를 녹일 수 있는 공기.
    *   **내부 공기:** 치즈 안에 갇힌 구멍 (치즈를 녹이지 못함).
*   단순히 "내 옆에 0이 있다"는 정보만으로는 그게 외부 공기인지 내부 공기인지 알 수 없다.

### 2.외부 공기부터 찾기 (BFS)
 **'치즈'가 아닌 '공기'를 기준**으로 생각하기로 했다.

**핵심 아이디어:**
> "외부 공기는 격자의 가장자리 `(0, 0)`부터 시작해서 모두 연결되어 있다."

이 성질을 이용해서 **BFS(Flood Fill)**를 사용했다.

1.  **(0, 0)에서 시작:** 이곳은 무조건 외부 공기이므로 침투 시작점이 된다.
2.  **BFS 탐색:** 상하좌우로 이동하며 공기(`0`)를 만나면 계속 큐에 넣고 범위를 넓혀간다.
3.  **녹을 치즈 발견:** 탐색 도중 치즈(`1`)를 만나면?
    *   그곳이 바로 **외부 공기와 닿은 경계면**이다.
    *   이 치즈는 이번 시간에 녹게 되므로 별도로 체크해둔다.
    *   단, 공기가 치즈를 뚫고 지나갈 수는 없으므로 **큐에는 넣지 않는다.**

이 방식을 쓰면 "내부 공기"를 따로 판별할 필요 없이, 외부 공기가 닿는 곳만 정확하게 골라낼 수 있다.

## 코드

{% raw %}
```java
public class Main {
  public static void main(String[] args) {
    try {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int[] nm = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
      int n = nm[0];
      int m = nm[1];

      int[][] maps = new int[n][m];
      int oneCount = 0;
      for (int i = 0; i < n; i++) {
        int[] s = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        maps[i] = s;
        oneCount += (int) Arrays.stream(s).filter(value -> value == 1).count();
      }

      if (oneCount == 0){
        System.out.println(0);
        System.out.println(0);
        return;
      }

      int[][] moves = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
      int count = 0;
      int answerOneCount;

      while(true){
        answerOneCount = 0;
        boolean[][] visited = new boolean[n][m];
        Deque<int[]> dq = new ArrayDeque<>();
        dq.add(new int[]{0, 0});
        visited[0][0] = true;
        while (!dq.isEmpty()) {
          int[] poll = dq.poll();
          for (int[] move : moves) {
            int nx = move[0] + poll[0];
            int ny = move[1] + poll[1];

            if (nx >= 0 && ny >= 0 && nx < n && ny < m && !visited[nx][ny]) {
              if (maps[nx][ny] == 0) {
                dq.add(new int[]{nx, ny});
              } else {
                answerOneCount += 1;
                maps[nx][ny] = 0;
              }
              visited[nx][ny] = true;
            }
          }
        }
        oneCount -= answerOneCount;
        count += 1;
        if(oneCount == 0){
          System.out.println(count);
          System.out.println(answerOneCount);
          return;
        }
      }

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```
{% endraw %}

