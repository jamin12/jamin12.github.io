---
layout: post
title: "백준 11722번 - 가장 긴 감소하는 부분 수열"
date: 2025-12-10 21:00:00 +0900
categories: [코테]
tags: [dp]
math: true
---

## 문제
{% include link-preview.html url="https://www.acmicpc.net/problem/11722" title="백준 11722번 문제" %}

## 풀이
이 문제는 **현재 원소($A[i]$)의 앞쪽($0 \sim i-1$)에 있는 원소들 중, 어떤 원소 뒤에 이어져야 감소하는 부분 수열의 길이가 최대가 될지**를 고려하면 됩니다.

$i$번째 원소의 상태는 **이전 위치들의 결과**에 따라 결정됩니다.

### 점화식 도출
생각보다 직관적입니다. "현재 원소보다 큰 수 뒤에만 붙을 수 있다"는 점만 기억하면 됩니다.

모든 $i$ (현재 위치)에 대하여, $j$ ($0$부터 $i-1$까지)를 순회하며 다음을 확인합니다.

* **현재 원소보다 큰 원소를 만났을 경우** ($A[j] > A[i]$)
    * 감소하는 조건을 만족하므로, $j$번째 원소 뒤에 $i$번째 원소를 붙일 수 있습니다.
    * $j$번째 원소까지의 최장 길이($DP[j]$)에 1을 더한 값이, 현재 저장된 $DP[i]$값보다 큰지 확인하여 갱신합니다.
    * $$DP[i] = \max(DP[i], \ DP[j] + 1)$$

* **현재 원소보다 작거나 같은 원소를 만났을 경우** ($A[j] \le A[i]$)
    * 감소하지 않으므로, $j$번째 원소 뒤에 붙을 수 없습니다.
    * 갱신하지 않고 넘어갑니다.

* **앞에 붙을 곳이 하나도 없을 경우**
    * 초기화 단계에서 설정한 대로, 해당 원소 하나만으로 수열을 이루므로 길이는 1입니다.
    * (코드에서는 처음에 모든 $DP$ 값을 1로 초기화하여 해결합니다.)

### 최종 정답
DP 테이블을 모두 채운 뒤, 마지막 칸이 아닌 **테이블 전체 중 최댓값**이 정답이 됩니다.
(수열이 반드시 마지막 원소에서 끝난다는 보장이 없기 때문입니다.)

$$Answer = \max(DP[0], DP[1], \dots, DP[N-1])$$

## 코드

```java
public class Main {
	public static void main(String[] args) {
		try {
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			int a = Integer.parseInt(br.readLine());
			int[] n = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();

			int[] dp = new int[a];
			dp[0] = 1;

			for (int i = 1; i < a; i++) {
				int max = 0;
				for (int j = 0; j < i; j++) {
					if (n[i] < n[j]) {
						max = Math.max(max, dp[j]);
					}
				}
				dp[i] = max + 1;
			}
			int answer = Arrays.stream(dp).max().getAsInt();

			System.out.println(answer);

		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```