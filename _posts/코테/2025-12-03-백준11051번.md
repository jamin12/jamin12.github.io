---
layout: post
title: "백준 11051번 "
date: 2025-12-04 20:31:00 +0900
categories: [코테]
tags: [dp]
math: true
---

## 문제

{% include link-preview.html url="https://www.acmicpc.net/problem/11051" title="백준 11051번 문제" %}

## 풀이

### 1\. 초기 접근: 팩토리얼 계산

처음에는 이항 계수의 정의 $\binom{N}{K} = \frac{N!}{K!(N-K)!}$ 를 그대로 구현하려고 했다.

**나의 시도:**

```java
// 팩토리얼 값을 미리 구해두고 계산하려 함
dp[i] = (dp[i - 1] * i) % 10007;
```

**문제점:**

  * 이 문제는 결과값을 **10,007로 나눈 나머지**를 구해야 한다.
  * 나눗셈 연산($/$)은 모듈러 연산($\%$)이 분배되지 않는다.
      * 즉, `(A / B) % P` $\neq$ `((A % P) / (B % P)) % P`
  * 따라서 팩토리얼로 푼다면 '모듈러 역원'이라는 복잡한 개념이 필요하다.

### 2\. 해결 전략 변경: 파스칼의 삼각형 (DP)

나눗셈 없이 **덧셈**만으로 이항 계수를 구할 수 있는 성질을 이용하기로 했다.

**핵심 점화식:**
$$\binom{N}{K} = \binom{N-1}{K-1} + \binom{N-1}{K}$$

> "$N$개 중 $K$개를 뽑는 경우의 수는, 특정 하나를 포함하는 경우와 포함하지 않는 경우의 합과 같다."

이 방식은 덧셈만 사용하므로 모듈러 연산(`% 10007`)을 매 단계마다 안전하게 적용할 수 있다.

## 코드

```java
public class Main {
	public static void main(String[] args) {
		try {
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			int[] nm = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
			int n = nm[0];
			int m = nm[1];

			int[][] dp = new int[n + 1][n + 1];
			for (int i = 0; i <= n; i++) {
				dp[i][0] = dp[i][i] = 1;
				for (int j = 1; j <= i; j++) {
					dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 10007;
				}
			}
			System.out.println(dp[n][m]);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```
