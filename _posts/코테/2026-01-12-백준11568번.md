---
layout: post
title: "백준 11568번"
date: 2026-01-12
categories: [코테]
tags: [dp]
math: true
---

## 문제

{% include link-preview.html url="https://www.acmicpc.net/problem/11568" title="백준 11568번 문제" %}

## 풀이

### 1. 초기 접근: O(n²) DP

가장 먼저 떠올릴 수 있는 방법은 다음 정의다.

**정의**

* `dp[i]` = `i`번째 원소를 **마지막으로 사용하는** 증가 부분 수열의 최대 길이

**점화식**

* `arr[j] < arr[i]` 인 모든 `j < i`에 대해
  `dp[i] = max(dp[j] + 1)`

이 방식은 직관적이지만,

* 매 `i`마다 이전 모든 `j`를 확인해야 해서
* 시간 복잡도가 **O(n²)** 이 된다.

입력 크기가 커지면 비효율적이다.

### 2. 관점 전환: “위치”가 아니라 “길이” 기준으로 생각하기

이 문제에서 중요한 건 **수열 자체가 아니라 길이**다.

그래서 다음처럼 관점을 바꾼다.

> “길이가 같은 증가 수열이라면,
> 끝값이 작을수록 다음 숫자를 붙이기 유리하다.”

이 말은 곧,

* 같은 길이의 증가 수열이 여러 개 있더라도
* **끝값이 최소인 경우 하나만 유지해도 충분**하다는 뜻이다.

### 3. dp 배열의 새로운 의미

새로운 dp 정의는 다음과 같다.

**정의**

* `dp[k]` = **길이가 `k+1`인 증가 부분 수열들 중에서, 끝값의 최소**

중요한 점:

* `dp`는 **실제 증가 수열이 아니다**
* “미래 확장 가능성이 가장 큰 상태만 요약해서 저장한 배열”이다

이 정의 때문에 다음 성질이 자동으로 성립한다.

* `dp[0] < dp[1] < dp[2] < ...`
  → 항상 **오름차순**

### 4. 새 숫자를 처리하는 방법

현재 숫자를 `x`라고 할 때,

1. `dp`에서
   **처음으로 `dp[pos] >= x` 가 되는 위치**를 찾는다
   (lower_bound)
2. 그 위치에 `x`를 **교체**한다.
3. 만약 그런 위치가 없다면 (`pos == len`)

   * 새로운 길이의 수열이 만들어진 것이므로 `len++`

교체해도 되는 이유는,

* 같은 길이라면 끝값이 더 작은 쪽이 항상 더 유리하기 때문이다.
* 이 과정은 최장 길이를 절대 줄이지 않는다.
아래처럼 **예시를 흐름대로 넣어서** 설명하면 이해가 훨씬 잘 된다.

<details markdown="1">
<summary> 예시로 이해하기 (클릭해서 펼치기) </summary>

예를 들어 입력이 다음과 같다고 하자.

``` text
6
9 10 8 11 9 12
```

이 수열의 정답은
`9 10 11 12` → **길이 4** 이다.

### dp의 의미 다시 정리

* `dp[k]` = **길이가 k+1인 증가 부분 수열 중, 끝값의 최소**
* `dp`는 실제 수열이 아니라 **상태 요약용 배열**
* `len` = 현재까지 만들 수 있는 최장 증가 부분 수열의 길이

### 단계별 진행 과정

#### 1. 첫 번째 값: 9

``` text
dp = [9]
len = 1
```

길이 1 수열의 최소 끝값은 9.

#### 2. 두 번째 값: 10

* dp에서 처음으로 `>= 10`인 위치 없음
* 맨 뒤에 추가

``` text
dp = [9, 10]
len = 2
```

#### 3. 세 번째 값: 8

* dp에서 처음으로 `>= 8`인 위치 → 0
* dp[0]을 8로 교체

``` text
dp = [8, 10]
len = 2
```

의미:

* 길이 1 수열의 끝값을 9 → 8로 더 좋게 만든 것
* 길이는 늘지 않음

#### 4. 네 번째 값: 11

* dp에서 처음으로 `>= 11`인 위치 없음
* 맨 뒤에 추가

``` text
dp = [8, 10, 11]
len = 3
```

#### 5. 다섯 번째 값: 9

* dp에서 처음으로 `>= 9`인 위치 → 1
* dp[1] 교체

``` text
dp = [8, 9, 11]
len = 3
```

길이 2 수열의 끝값을 더 작게 갱신한 것.

#### 6. 여섯 번째 값: 12

* dp에서 처음으로 `>= 12`인 위치 없음
* 맨 뒤에 추가

``` text
dp = [8, 9, 11, 12]
len = 4
```

### 중요한 포인트

dp[0] = 8
→ 길이 1 증가 수열이 존재

dp[1] = 9
→ 길이 2 증가 수열이 존재

dp[2] = 11
→ 길이 3 증가 수열이 존재

dp[3] = 12
→ 길이 4 증가 수열이 존재

각 단계에서 dp[k]는
**“그 길이를 만들 수 있었던 어떤 실제 수열 중 하나의 끝값”**이다.

</details>

### 5. 왜 이분 탐색이 가능한가

`dp`는 항상 오름차순을 유지한다.

* 정의 자체가 “길이별 최소 끝값”이기 때문
* 교체도 오름차순을 깨지 않는 위치에서만 일어난다

그래서

* 매 숫자마다 위치를 **이분 탐색**으로 찾을 수 있고
* 전체 시간 복잡도는 **O(n log n)** 이 된다.

## 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        int[] arr = Arrays.stream(br.readLine().split(" "))
                          .mapToInt(Integer::parseInt)
                          .toArray();

        int[] dp = new int[t];
        dp[0] = arr[0];
        int len = 1;

        for (int i = 1; i < t; i++) {
            int l = 0, r = len;
            while (l < r) {
                int m = (l + r) / 2;
                if (dp[m] < arr[i]) {
                    l = m + 1;
                } else {
                    r = m;
                }
            }
            dp[l] = arr[i];
            if (l == len) {
                len++;
            }
        }

        System.out.println(len);
    }
}
```

## 정리

* 이 풀이는 **수열을 직접 만들지 않는다**
* 대신

  * “길이별 최소 끝값”만 관리해서
  * 불필요한 경우를 전부 제거한다
* `dp`의 길이(`len`) 자체가 정답이다

핵심 한 줄 요약:

> **LIS 이분 탐색 풀이는
> ‘정답 후보를 압축해서 관리하는 DP’다.**
