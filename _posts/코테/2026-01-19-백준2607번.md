---
layout: post
title: "백준 2607번"
date: 2026-01-19
categories: [코테]
tags: [string]
math: true
---

## 문제

{% include link-preview.html url="https://www.acmicpc.net/problem/2607" title="백준 2607번 문제" %}

## 풀이

### 1. 초기 접근: 케이스별 분기

처음에는 비교 단어의 문자 개수를 `groupBy`로 세고, 기준 단어와 비교하면서 조건을 나누려고 했다.

구체적으로는:
- `compairWord.entries`를 순회하며 기준 단어와 차이가 나는 문자를 찾고
- 차이 나는 문자 개수로 케이스를 분류
- 길이 차이나 특정 문자 개수 차이를 직접 비교

**문제점:**

이 방식은 다음 상황들을 제대로 처리하지 못했다.

1. **기준 단어에만 있는 문자를 놓침**
   - `compairWord.entries`만 순회하기 때문에, 기준 단어에만 존재하는 문자는 검사 대상에서 빠짐
   - 예: 기준 `AAB`, 비교 `BBB` → A는 차이 계산에 포함되지 않음

2. **교체 1번 케이스를 놓침**
   - 교체는 문자 2종류에서 동시에 차이가 발생함 (하나는 +1, 하나는 -1)
   - 예: 기준 `AAB`, 비교 `ABB` → A는 -1, B는 +1
   - `fCondition.size == 1` 같은 조건으로는 이 패턴을 잡아낼 수 없음

3. **중복 카운트 발생**
   - `forEach` 안에서 조건 만족 시마다 `answer++`를 해서, 한 단어가 여러 번 카운트됨

이런 문제들이 겹치면서 조건문이 계속 늘어났지만 정확한 판정을 할 수 없었다.

### 2. 관점 전환: 차이를 수치로 표현하기

이 문제의 핵심은 "비슷한 단어" 조건이 다음 중 하나라는 점이다.

- 완전히 같음 (0번 연산)
- 문자 1개 추가
- 문자 1개 삭제
- 문자 1개 교체

이 조건을 케이스별로 나누는 대신, **전체 차이의 총량**으로 판단하는 방식으로 바꿨다.

**새로운 접근:**

1. 모든 알파벳(A~Z)에 대해 `기준 개수 - 비교 개수`를 계산
2. 그 차이를 두 가지로 누적
   - `plus`: 기준 단어가 더 많은 문자들의 개수 합
   - `minus`: 비교 단어가 더 많은 문자들의 개수 합
3. `(plus, minus)` 패턴이 `(0,0)`, `(1,0)`, `(0,1)`, `(1,1)` 중 하나면 "비슷한 단어"


- 어느 문자에서 차이가 나는지 일일이 확인하지 않아도 됨
- 교체/추가/삭제가 자연스럽게 같은 기준으로 처리됨
- 한 단어당 판정이 딱 1번만 일어남

### 3. 예시

**예시 1: 교체 1번**

기준: `AAB` (A:2, B:1)
비교: `ABB` (A:1, B:2)

```
A: 2 - 1 = +1 → plus += 1
B: 1 - 2 = -1 → minus += 1
```

`plus = 1, minus = 1` → 교체 1번으로 가능

**예시 2: 삭제 1번**

기준: `AAB`
비교: `AB`

```
A: 2 - 1 = +1 → plus += 1
B: 1 - 1 = 0
```

`plus = 1, minus = 0` → 삭제 1번으로 가능

**예시 3: 불가능한 케이스**

기준: `AABC`
비교: `BBBD`

```
A: 2 - 0 = +2 → plus += 2
B: 1 - 3 = -2 → minus += 2
C: 1 - 0 = +1 → plus += 1
D: 0 - 1 = -1 → minus += 1
```

`plus = 3, minus = 3` → 한 번의 연산으로 불가능

**중요한 점:**

- 서로 다른 문자에서 `+`와 `-`가 발생해도 상관없음
- `plus`와 `minus`는 "전체적으로 몇 번의 연산이 필요한지"를 나타내는 총량
- 교체는 본질적으로 삭제 1 + 추가 1이라서 `plus = 1, minus = 1`로 표현됨

## 코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader

private fun countLetters(s: String): IntArray {
    val cnt = IntArray(26)
    for (ch in s) cnt[ch - 'A']++
    return cnt
}

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {
    val n = readLine().trim().toInt()
    val base = readLine().trim()
    val baseCnt = countLetters(base)

    var ans = 0

    repeat(n - 1) {
        val w = readLine().trim()
        val wCnt = countLetters(w)

        var plus = 0
        var minus = 0

        for (i in 0 until 26) {
            val diff = baseCnt[i] - wCnt[i]
            if (diff > 0) plus += diff
            else if (diff < 0) minus += -diff
        }

        if ((plus == 0 && minus == 0) ||
            (plus == 1 && minus == 0) ||
            (plus == 0 && minus == 1) ||
            (plus == 1 && minus == 1)
        ) {
            ans++
        }
    }

    print(ans)
}
```
