---
layout: post
title: "WHERE 절의 4단계 처리 과정: 논리부터 표현식까지"
date: 2026-01-02
categories: [개념정리, databases]
tags: [databases, where, optimizer, execution_plan]
math: true
---

DB가 `WHERE` 절을 처리하는 과정은 크게 **논리적 처리**, **물리적 최적화**, **물리적 실행**, **표현식 평가**의 4단계로 나누어 볼 수 있다.

## 1. 논리적 처리 단계 (Logical Processing)

이 단계는 "무엇(What)을 원하는가"를 정의하는 단계다. 실행 계획, 인덱스, 메모리 버퍼 등은 고려되지 않으며, 오직 수학적 의미(관계대수)만이 중요하다.

### 1-1. 관계대수 (Relational Algebra) 표현

SQL은 사람이 읽기 쉬운 언어일 뿐, DB 엔진은 이를 관계대수 연산으로 변환하여 이해한다.

**예제 SQL:**

```sql
SELECT id, name
FROM users
WHERE age >= 20 AND city = 'Seoul';
```

**변환된 관계대수 수식:**
$$ \pi_{id, name}(\sigma_{age \ge 20 \land city = 'Seoul'}(users)) $$

* **Selection ($\sigma$)**: `WHERE` 절에 해당한다. 전체 집합에서 조건에 맞는 **수평적 부분 집합**을 정의한다.
* **Projection ($\pi$)**: `SELECT` 절에 해당한다. 필요한 속성(컬럼)만 남기는 **수직적 부분 집합**을 정의한다.

개발자가 `WHERE`를 먼저 썼든 나중에 썼든, 관계대수적으로는 "조건에 맞는 튜플의 집합"이라는 정의 자체가 변하지 않는다.

### 1-2. 선언적 의미와 집합론

`WHERE status = 'FAILED'`를 절차적으로 해석하면 "한 줄씩 읽어서 `status`가 `FAILED`인지 확인한다"가 된다. 하지만 논리적 단계에서는 이를 집합론적으로 해석한다.

> "이 릴레이션(테이블)은 본래 `status`가 `FAILED`인 튜플들로만 구성되어 있다."

즉, 필터링(Filtering)이라기보다는 **조건을 만족하는 집합의 선언(Declaration)** 이다.

조금 더 쉽게 말하면 “집합론적으로 해석한다”는 말은 논리적 처리 단계에서는 WHERE status = 'FAILED'를

“FAILED인 행을 찾아라”가 아니라 “FAILED인 행들의 집합을 정의한다” 로 이해한다는 뜻이다.

### 1-3. 논리 트리(Logic Tree)와 정규화

복잡한 `AND`/`OR` 조건은 논리 트리로 변환된 후 **CNF(Conjunctive Normal Form)** 등으로 정규화된다.

**예제:**

```sql
WHERE (A=1 OR B=1) AND (C=1 OR D=1)
```

DB는 이를 트리 구조로 만들어 중복된 조건을 제거하거나, 연산 순서를 재배열해도 결과가 같음을 보장하는 수학적 동치 변환을 수행한다.

## 2. 옵티마이저 단계 (Optimizer)

논리적 정의가 끝나면, "어떻게(How) 가져올 것인가"를 결정한다. 여기서 `WHERE` 절은 비용(Cost) 계산의 핵심 재료가 된다.

### 2-1. 선택도(Selectivity) 계산

선택도는 특정 조건이 전체 데이터 중 몇 퍼센트를 남길지 예측하는 수치다. (0 ~ 1 사이의 값)

**공식:**
$$ Selectivity = \frac{\text{Filtered Rows}}{\text{Total Rows}} $$

**구체적 사례:**
만약 `users` 테이블에 100만 건의 데이터가 있고, `gender` 컬럼 분포가 50:50이라면?

* Query: `WHERE gender = 'M'`
* Selectivity: 0.5 (50%)
* **판단**: "50만 건이나 읽어야 해? 인덱스 타는 것보단 그냥 Full Scan이 빠르겠군."

만약 `user_id` 처럼 유니크하다면?

* Query: `WHERE user_id = 1234`
* Selectivity: $1/1,000,000 = 0.000001$
* **판단**: "극소수만 가져오네. Index Seek가 무조건 유리하다."

#### 2-1-1. 선택도는 어떻게 “예측”되는가

중요한 전제부터 정리하면,
옵티마이저는 쿼리를 실행해서 행 개수를 세지 않는다.
실행 전에 그런 건 불가능하다.

대신 DB는 사전에 수집해 둔 통계 정보(statistics) 를 이용해 결과 크기를 추정한다.

DB는 테이블과 인덱스에 대해 정보를 미리 알고 있다.

* 전체 행 수 (row count)
* 컬럼별 DISTINCT 값 개수
* 값 분포(비율)
* 최소값 / 최대값
* 히스토그램(값 쏠림)

동등 조건(=)의 예측 방식

```sql
WHERE gender = 'M'
```

옵티마이저의 사고 흐름은 다음과 같다.

* users 전체 행 수 = 1,000,000
* gender 컬럼 DISTINCT = 2
* 분포가 균등하다고 가정

그래서:

``` text
예상 결과 행 수 ≈ 1,000,000 / 2 = 500,000
선택도 ≈ 0.5
```

여기서 중요한 점은
**M이라는 값을 실제로 찾은 적이 없다는 것**이다.
단지 “이 컬럼 구조상 한 값이 차지할 비율”을 계산한 것이다.

유니크 컬럼의 예측 방식

```sql
WHERE user_id = 1234
```

통계에는 이미:

* user_id는 UNIQUE
* DISTINCT = 전체 행 수

라는 정보가 있다.

그래서 옵티마이저는:

``` text
예상 결과 행 수 ≈ 1
선택도 ≈ 1 / row_count
```

라고 즉시 판단한다.

이 역시 실행 결과가 아니라
**컬럼의 성질로부터 나온 결론**이다.

범위 조건의 예측 방식

```sql
WHERE created_at >= '2025-01-01'
```

이 경우 옵티마이저는:

* created_at 최소값
* created_at 최대값

을 기준으로
전체 범위 중 조건이 차지하는 비율을 계산한다.

예를 들어:

* 전체 기간: 5년
* 조건 범위: 1년

이면:

``` text
선택도 ≈ 1 / 5 = 0.2
```

실제 데이터 분포가 어떻든,
통계상 범위 기준으로 일단 추정한다.

### 2-2. 카디널리티(Cardinality) 추정과 실행 계획

옵티마이저는 선택도를 기반으로 각 단계의 결과 건수(Cardinality)를 추정한다.

**예제:**

```sql
SELECT *
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 'REFUND'  -- 조건 A
  AND u.level = 'VIP';    -- 조건 B
```

**옵티마이저의 사고 과정:**

1. **통계 정보 확인**: `orders` 테이블에 1,000만 건, `REFUND` 비율은 1%.
    * 예상 Row: 10만 건.
2. **통계 정보 확인**: `users` 테이블에 100만 건, `VIP` 비율은 0.1%.
    * 예상 Row: 1,000 건.
3. **조인 순서 결정**: "작은 집합을 드라이빙(Driving) 하는 게 유리하다."
    * **결정**: `users` (1,000건) → `orders` (Index Look up) 순서로 조인한다.

만약 통계가 낡아서 `VIP`가 사실 50만 명이었다면? 옵티마이저는 잘못된 순서로 조인을 시도해 성능 대참사(Slow Query)가 발생한다.

### 2-3. 고급 최적화 기법 (Advanced Optimization)

옵티마이저는 `WHERE` 절을 적극적으로 변형(Rewrite)하여 성능을 극대화한다.

* **Predicate Pushdown**: 조인보다 필터링을 먼저 수행하여 데이터 양을 미리 줄인다.
* **Transitive Closure**: `A=B`이고 `B=1`이면 `A=1`임을 스스로 추론해낸다.
* **Constant Folding**: 함수(`NOW()` 등)를 미리 계산하여 상수로 변환, 인덱스 활용을 돕는다.

## 3. 물리 실행 단계 (Physical Execution)

실행 계획이 수립되면, DB 엔진은 실제로 데이터를 읽고 조건을 평가한다. 이 단계부터는 `WHERE` 절이 더 이상 단일 개념이 아니라, **스토리지 엔진**과 **실행 엔진** 사이에서 분업화된 형태로 존재한다.

### 3-1. Index Condition vs Filter

실행 단계에서 `WHERE` 조건은 크게 두 가지로 나뉜다. 이 구분은 쿼리 튜닝의 핵심이다.

1. **Index Condition (Access Predicate)**
    * **역할**: 인덱스 검색의 시작점과 끝점을 결정한다.
    * **시점**: 디스크(또는 메모리 버퍼)에서 데이터를 읽어오기 **전**에 평가된다.
    * **효과**: 읽어야 할 데이터 자체를 획기적으로 줄여준다. (I/O 감소의 핵심)

2. **Filter (Filter Predicate)**
    * **역할**: 인덱스로 걸러내지 못한 나머지 조건을 확인한다.
    * **시점**: 데이터를 읽어온 **후**에 메모리 상에서 CPU가 평가한다.
    * **효과**: 불필요한 데이터를 결과 집합에서 제거하지만, 이미 I/O는 발생했다.

**예시:**

```sql
SELECT * FROM users WHERE id BETWEEN 100 AND 200 AND name LIKE '%Kim%';
```

* `id BETWEEN 100 AND 200`: **Index Condition** (100~200 범위만 스캔)
* `name LIKE '%Kim%'`: **Filter** (읽어온 100개의 행 중 Kim을 찾음)

### 3-2. 스캔 방식에 따른 적용

데이터 접근 방식(Access Method)에 따라 `WHERE`의 적용 위치가 달라진다.

* **Index Scan**: `Index Condition`으로 범위를 좁히고, 인덱스에 없는 컬럼 조건은 테이블 랜덤 액세스 후 `Filter`로 처리한다.
* **Index Only Scan**: 테이블 접근 없이 인덱스 내부에서 모든 조건을 평가하고 데이터를 반환한다.
* **Full Table Scan (Seq Scan)**: 인덱스를 타지 않으므로 `WHERE` 절의 모든 조건이 `Filter`로 작동한다. "Scan을 한다"는 것은 데이터를 다 읽으면서 조건을 체크한다는 뜻이다.

### 3-3. 조인(Join) 단계에서의 분해

조인 쿼리에서 `WHERE` 조건은 실행 시점에 흩어진다.

```sql
SELECT * FROM A JOIN B ON A.id = B.id WHERE B.status = 'active';
```

실행 엔진은 이를 다음과 같이 처리할 수 있다.

1. **B 테이블 스캔 시**: `status = 'active'`를 먼저 필터링하고 조인에 참여시킨다. (Pushdown 효과)
2. **조인 연결 시**: 조인 키(`A.id = B.id`) 매칭에 실패하면 즉시 버린다.
3. **조인 완료 후**: 조인된 결과 셋에서 최종 필터링을 수행한다.

## 4. 표현식 평가 단계 (Expression Evaluation)

가장 미시적인 단계로, **하나의 행(Row)**에 대해 조건식이 참인지 거짓인지 판별하는 규칙이다. SQL 표준(ANSI SQL)이 정의한 3-valued Logic과 NULL 처리가 여기서 이루어진다.

### 4-1. 3-Valued Logic (3가 논리)

프로그래밍 언어(Boolean)와 달리, 데이터베이스 논리에는 세 가지 상태가 있다.

* **TRUE**: 조건 만족.
* **FALSE**: 조건 불만족.
* **UNKNOWN**: 알 수 없음 (주로 `NULL` 연산 결과).

**핵심 규칙**: `WHERE` 절은 오직 결과가 **TRUE**인 행만 반환한다. FALSE와 UNKNOWN은 모두 탈락시킨다.

### 4-2. NULL과 UNKNOWN의 함정

NULL은 "값이 없음"을 의미하므로, 어떤 값과 비교해도 결과는 알 수 없다(UNKNOWN).

* `col = NULL` → **UNKNOWN** (탈락)
* `col != NULL` → **UNKNOWN** (탈락)
* `NOT (col = NULL)` → `NOT (UNKNOWN)` → **UNKNOWN** (탈락)

따라서 NULL을 찾으려면 비교 연산자(`=`)가 아닌 `IS NULL`을 사용해야 한다. 많은 버그가 `NOT IN`이나 `!=` 사용 시 NULL 데이터가 포함되어 있을 때 발생한다.

```sql
-- 의도: 값이 10이 아닌 데이터 조회
-- 결과: 10이 아닌 데이터 + NULL 데이터는 제외됨!
SELECT * FROM table WHERE col != 10;
```

### 4-3. 단락 평가(Short-circuit)의 미보장

프로그래밍 언어(Java, Python)에서는 `A AND B`에서 `A`가 거짓이면 `B`를 실행하지 않는다. 이를 단락 평가라 한다.
하지만 **SQL에서는 단락 평가가 보장되지 않는다.**

```sql
SELECT * FROM table WHERE my_col IS NOT NULL AND my_func(my_col) = 1;
```

옵티마이저는 효율성을 위해 `my_func()`를 먼저 실행할 수도 있다. 만약 `my_col`이 NULL일 때 `my_func`가 오류를 뱉는다면? 쿼리는 실패할 수 있다. SQL은 선언적 언어이므로, **평가 순서는 전적으로 DB 마음**이다.

### 4-4. 결정론적 함수와 비결정론적 함수

`WHERE` 절에 함수를 사용할 때 주의점이다.

* **Deterministic (결정론적)**: 입력이 같으면 결과가 항상 같다 (예: `ABS()`, `SUBSTR()`). 인덱스 활용이 제한적으로나마 가능할 수 있다(Function-based Index).
* **Nondeterministic (비결정론적)**: 호출할 때마다 값이 변한다 (예: `RAND()`, `NOW()`). 조건 평가 시 매 행마다 재계산해야 하므로 성능에 치명적일 수 있다.

## 전체 요약

1. **논리 단계**: "무엇을 원하는가"를 정의한다. `WHERE`는 집합을 한정하는 선언이다.
2. **옵티마이저 단계**: "어떻게 가져올까"를 계획한다. 선택도/비용을 계산하여 인덱스 사용 여부를 결정한다.
3. **실행 단계**: "어떤 방식으로 거를까"를 수행한다. 인덱스 단계(Access)와 메모리 단계(Filter)로 나뉜다.
4. **평가 단계**: "이 행이 조건에 맞는가"를 판별한다. 3-Value Logic과 NULL 처리에 주의해야 한다.
