---
layout: post
title: "tls 과정 정리"
date: 2025-12-28 14:00:00 +0900
categories: [개념 정리, network]
tags: [tls]
mermaid: true
---

## TLS 검증 과정은 언제, 왜 일어나는가

TLS 연결에서 “검증”은 **연결 초반에 단 한 번** 일어난다.
그리고 이 검증이 끝나기 전까지는,

* 서버가 진짜인지
* 통신을 계속해도 되는지

아무것도 확정되지 않는다.

검증에 실패하면:

* 일반 HTTPS: 경고 화면
* HSTS: 즉시 차단

TLS 검증은 **서버 인증서가 전달된 직후** 시작된다.

## ca 검증 과정

### 1. 서버 인증서는 언제 전달되는가

TLS 연결이 시작되면 흐름은 이렇게 진행된다.

1. 클라이언트가 `ClientHello`를 보낸다
2. 서버가 `ServerHello`를 보낸다
3. **서버가 자신의 인증서를 함께 보낸다**

이때 서버가 보내는 인증서가 바로:

* 서버 인증서 (`noo-monitoring.crt`)

이 인증서 안에는 다음 정보가 들어 있다.

* 서버 공개키
* SAN (도메인 목록)
* 발급자(CA) 정보
* CA의 서명

이 순간부터 **TLS 검증이 시작된다**.

### 2. TLS 검증의 첫 단계: “누가 이걸 발급했나”

클라이언트는 인증서를 받자마자 가장 먼저 이걸 본다.

* Issuer: 이 인증서를 서명한 CA는 누구인가

이 값은 인증서 안에 명시되어 있다.

클라이언트는 여기서 바로 판단하지 않는다.
다음 질문으로 넘어간다.

### 3. 두 번째 단계: “그 CA를 내가 신뢰하나”

클라이언트는 자신의 Trust Store(OS 또는 브라우저)에 가서:

* Issuer에 해당하는 CA 인증서가 있는지 찾는다
* Trust Store에 들어 있는 것은 **CA의 공개키**다
* CA가 Trust Store에 없다면
  → 이 시점에서 검증 실패

HSTS 환경에서는 바로 연결이 종료된다.

### 4. 세 번째 단계: “이 인증서는 위조되지 않았나”

CA가 Trust Store에 있다면, 클라이언트는 다음 검증을 한다.

* CA 공개키로
* 서버 인증서의 **서명**을 검증한다

이 검증이 의미하는 것은 이거다.

> “이 인증서는
> 정말 이 CA의 개인키로 서명된 것이 맞다”

### 5. 네 번째 단계: “이 인증서는 이 도메인용인가”

서명이 검증되면, 클라이언트는 이제 도메인을 확인한다.

검사 대상은 **CN이 아니라 SAN**이다.

클라이언트는 다음을 비교한다.

* 내가 접속한 도메인 (예: `noo.grafana.com`)
* 인증서의 SAN 목록

규칙은 단순하다.

* SAN에 도메인이 있으면 → 통과
* 없으면 → 실패

CN은 이 판단에 사용되지 않는다.

### 6. 다섯 번째 단계: “유효기간은 괜찮은가”

마지막으로 클라이언트는 시간 관련 검증을 한다.

* 인증서가 아직 유효한가
* 만료되지 않았는가
* 아직 사용 가능한 시점인가

## 서버 개인키 검증

* 인증서 검증 → CA 공개키로 수행
* 개인키 검증 → **Handshake 메시지 서명으로 수행**

### 1. CA 검증이 끝났을 때의 상태

CA 검증이 끝난 시점에서 클라이언트의 상태는 이렇다.

* 이 인증서는
  * 신뢰된 CA가 서명했고
  * 위조되지 않았고
  * 이 도메인용이 맞다
* 하지만 아직 모르는 것:
  * **지금 통신 중인 이 서버가 이 인증서의 개인키를 실제로 가지고 있는가?**

### 2. 서버 개인키 검증은 “Handshake 메시지 서명”이다

TLS에서 서버 개인키 검증은
**“개인키를 가진 서버만 만들 수 있는 서명”** 으로 이루어진다.

### 3. TLS 1.2 / TLS 1.3 공통 개념

* 클라이언트와 서버는
  * 지금까지 주고받은 Handshake 메시지 전체를 기준으로
* 서버는
  * **자기 개인키로 이 내용을 서명**한다
* 클라이언트는
  * 인증서에 들어 있던 **서버 공개키로 그 서명을 검증**한다

### 4. TLS 1.2 기준 설명

TLS 1.2(ECDHE) 기준으로 보면 흐름은 이렇다.

#### ① 키 교환 정보 생성

* 클라이언트와 서버는
  * 임시 키 교환 정보(ECDHE)를 생성한다

#### ② ServerKeyExchange 메시지

* 서버는 이 메시지에

  * **자기 개인키로 서명한 데이터**를 포함한다
* 이 서명에는:

  * 클라이언트 랜덤
  * 서버 랜덤
  * 키 교환 파라미터
    가 포함된다

#### ③ 클라이언트 검증

* 클라이언트는
  * 인증서에서 얻은 **서버 공개키**로
  * 이 서명을 검증한다

### 5. TLS 1.3 기준 설명 (현대 방식)

TLS 1.3에서는 구조가 더 단순해졌다.

#### 핵심 메시지: CertificateVerify

* 서버는

  * 지금까지의 Handshake transcript 전체를
  * **서버 개인키로 서명**
* 클라이언트는

  * 서버 인증서의 **공개키로 검증**

``` mermaid
sequenceDiagram
    participant C as Client (Browser)
    participant S as Server (Istio Ingress Gateway)
    participant CA as CA (Trust Store)

    %% TLS Handshake 시작
    C->>S: ClientHello (TLS 버전, 암호 스위트, Client Random)

    S->>C: ServerHello (선택된 암호 스위트, Server Random)
    S->>C: Certificate (noo-monitoring.crt= 서버 공개키 + SAN + CA 서명)

    %% 인증서 검증 (CA 체인)
    C->>CA: CA 공개키 조회 (Trust Store)
    CA-->>C: CA 공개키
    C->>C: 인증서 서명 검증 (CA 공개키 사용)
    C->>C: SAN 도메인 검증 (접속 도메인 일치 여부)
    C->>C: 유효기간 검증

    alt 인증서 검증 실패
        C-->>S: TLS 연결 종료 (HSTS면 즉시 차단)
    end

    %% 서버 개인키 증명
    S->>C: CertificateVerify (Handshake transcript를 서버 개인키로 서명)
    C->>C: 서버 공개키로 서명 검증

    alt 개인키 검증 실패
        C-->>S: TLS Handshake 실패
    end

    %% 세션 키 합의
    C->>S: Finished(세션 키 기반 MAC)
    S->>C: Finished(세션 키 기반 MAC)

    %% 이후 통신
    Note over C,S: 이후 모든 통신은\n세션 키(대칭키)로 암호화
```
