---
layout: post
title: "Elasticsearch 기본 개념"
date: 2026-02-15
categories: [개념정리, elasticsearch]
tags: [elasticsearch, crud, kibana]
---

## Elasticsearch 개요

공식 홈페이지에는 "오픈 소스 분산, RESTful 검색 및 분석 엔진, 확장 가능한 데이터 저장소 및 벡터 데이터베이스"라고 되어 있다. 요약하면 검색과 데이터 분석에 최적화된 데이터베이스다.

실무에서는 크게 두 가지 용도로 쓰인다.

**데이터 수집 및 분석** — 대규모 로그 등을 수집·분석할 때 Elasticsearch(저장) + Logstash(수집·가공) + Kibana(시각화)를 묶어서 사용한다.

**검색 최적화** — 데이터가 많아도 빠른 검색 속도를 제공하고, 오타·동의어를 고려한 유연한 검색이 가능하다. 쿠팡이나 배달의민족의 검색 기능도 Elasticsearch 기반이다.

## 통신 방식

MySQL이 SQL문으로 소통하는 것과 달리, Elasticsearch는 REST API로 통신한다.

같은 데이터 삽입이라도 문법이 다르다.

```sql
-- MySQL
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
```

```bash
# Elasticsearch
curl -X POST "localhost:9200/users/_doc" -H 'Content-Type: application/json' -d'
{
  "name": "Alice",
  "email": "alice@example.com"
}'
```

매번 cURL이나 Postman으로 요청을 보내는 건 번거롭기 때문에, 실무에서는 Kibana의 Dev Tools를 사용한다.

## 기본 용어 — MySQL 대응 관계

MySQL과 Elasticsearch는 용어만 다를 뿐 개념이 대응된다.

| MySQL | Elasticsearch | 설명 |
|---|---|---|
| 테이블(table) | 인덱스(index) | 데이터를 담는 저장소 |
| 스키마(schema) | 매핑(mapping) | 필드 이름과 타입을 정의한 구조 규칙 |
| 컬럼(column) | 필드(field) | 개별 데이터 항목 (이름 + 타입) |
| 레코드(record) / 로우(row) | 도큐먼트(document) | 하나의 데이터 단위 |

MySQL에서의 '인덱스(index)'와 Elasticsearch의 '인덱스(index)'는 완전히 다른 개념이다. MySQL의 인덱스는 검색 성능을 높이기 위한 자료구조이고, Elasticsearch의 인덱스는 데이터를 담는 테이블에 해당한다.

## 인덱스 생성, 조회 및 삭제

Elasticsearch에서 인덱스를 생성하는 것은 MySQL에서 테이블을 만드는 것에 해당한다.

### 인덱스 생성 및 조회

```
# 인덱스 생성
PUT /users

# 인덱스 조회
GET /users
```

존재하지 않는 인덱스를 조회하면 404 에러가 발생한다.

```
GET /abc    # 404 에러 발생
```

### 인덱스 삭제

```
# 인덱스 삭제
DELETE /boards

# 삭제 확인
GET /boards
```

## 매핑(mapping) 정의

매핑은 MySQL의 스키마 정의에 해당한다. 필드별로 데이터 타입을 지정한다.

```json
PUT /users/_mappings
{
  "properties": {
    "name": { "type": "keyword" },
    "age": { "type": "integer" },
    "is_active": { "type": "boolean" }
  }
}
```

정의한 매핑은 `GET /users`로 확인할 수 있다.

## 도큐먼트 삽입

도큐먼트 삽입은 MySQL의 INSERT에 해당한다.

```json
POST /users/_doc
{
  "name": "Alice",
  "age": 28,
  "is_active": true
}
```

`GET /users/_search`로 전체 도큐먼트를 조회하면 응답에서 주요 필드는 다음과 같다.

- **`_index`** — 인덱스명
- **`_id`** — 자동 생성된 고유 ID
- **`_source`** — 저장된 실제 데이터

## 도큐먼트 CRUD

### 1. 저장 (Create)

저장 방법은 세 가지가 있다.

**① id 자동 생성**

```json
POST /users/_doc
{
  "name": "Jaeseong",
  "age": 20,
  "is_active": true
}
```

**② id 직접 지정**

```json
POST /users/_create/1
{
  "name": "jscode",
  "age": 30,
  "is_active": true
}
```

이미 존재하는 id로 저장하면 에러가 발생한다.

**③ id 직접 지정 + UPSERT (PUT)**

```json
PUT /users/_doc/2
{
  "name": "jason",
  "age": 30,
  "is_active": true
}
```

PUT은 해당 id가 없으면 새로 저장하고, 이미 존재하면 덮어쓴다. UPSERT 방식이다. HTTP 메서드가 POST가 아니라 PUT이라는 점이 다르다.

### 2. 조회 (Read)

**전체 조회**

```
GET /users/_search
```

**단건 조회 (id 기준)**

```
GET /users/_doc/1
GET /users/_doc/2
```

이 외에 다양한 조건 기반 조회가 있지만, 여기서는 기본 CRUD 범위까지만 정리했다.

### 3. 수정 (Update)

**① 도큐먼트 전체 덮어쓰기**

```json
PUT /users/_doc/1
{
  "name": "new"
}
```

저장 API와 동일한 방식이다. 기존 도큐먼트의 모든 필드가 새 값으로 대체되므로, 지정하지 않은 필드(age, is_active 등)는 사라진다.

**② 일부 필드만 수정**

```json
POST /users/_update/2
{
  "doc": {
    "age": 10,
    "is_active": false
  }
}
```

`_update` API를 사용하면 변경할 필드만 지정할 수 있다. 나머지 필드는 유지된다.

### 4. 삭제 (Delete)

```
DELETE /users/_doc/2

# 삭제 확인
GET /users/_doc/2
```

## CRUD API 요약

| 기능 | HTTP 메서드 | API | 비고 |
|---|---|---|---|
| 저장 (id 자동) | `POST` | `/{인덱스명}/_doc` | id 랜덤 생성 |
| 저장 (id 지정) | `POST` | `/{인덱스명}/_create/{id}` | 중복 id 시 에러 |
| 저장/수정 (UPSERT) | `PUT` | `/{인덱스명}/_doc/{id}` | 없으면 생성, 있으면 덮어쓰기 |
| 전체 조회 | `GET` | `/{인덱스명}/_search` | |
| 단건 조회 | `GET` | `/{인덱스명}/_doc/{id}` | |
| 일부 수정 | `POST` | `/{인덱스명}/_update/{id}` | doc 필드에 변경값 전달 |
| 삭제 | `DELETE` | `/{인덱스명}/_doc/{id}` | |
