---
layout: post
title: "pact 용어 정리"
date: 2025-12-20
categories: [개념정리, pact]
tags: [cdc, pact, 러너스하이2_주제1]
---

## 기본 용어 테이블

| 구분 | 용어 | 의미 |
|---|---|---|
| 관계 | Consumer | 다른 서비스의 API를 호출하는 쪽 |
| 관계 | Provider | API를 제공하는 쪽 |
| 계약 | Contract | Consumer와 Provider 사이의 약속 |
| 계약 | Pact File | Contract를 파일 형태로 표현한 것 |
| 계약 | Interaction | 요청 1번 + 응답 1번에 대한 계약 단위 |
| 계약 | Provider State | Interaction이 성립하기 위한 Provider의 상태 이름 |
| 테스트 | Consumer Pact Test | Consumer 관점에서 계약을 생성하는 테스트 |
| 테스트 | Provider Verification | Provider가 계약을 만족하는지 검증하는 테스트 |
| 테스트 | Mock Server | Consumer 테스트 중 Provider를 대신하는 서버 |
| 실행 | @TestTemplate | Interaction 단위 실행을 가능하게 하는 JUnit 메커니즘 |
| 실행 | Extension | 테스트 실행 흐름에 개입하는 JUnit 확장 |
| 저장소 | Pact Broker | Pact file을 저장·공유하는 중앙 저장소 |

## interaction은 API가 아니다

interaction은 엔드포인트 자체가 아니라  
**API의 한 가지 사용 케이스**다.

- 같은 path
- 같은 method

라도

- 응답이 다르거나
- 전제 상태가 다르면

다른 interaction으로 분리된다.

Pact에서의 최소 단위는 API가 아니라 **요청–응답 시나리오**다.

## pact file은 실행 단위가 아니다

interaction이 여러 개 있어도 pact file은 하나다.
pact file의 기준은 항상 이렇다.

- Consumer 1
- Provider 1

그 안에 Consumer가 Provider를 사용하면서 정의한  
모든 interaction이 들어간다.

실제로 실행·검증되는 단위는  
항상 **interaction**이다.

## Provider는 interaction 기준으로 검증한다

Provider 검증은 pact file을 통째로 처리하지 않는다.

- interaction 하나를 꺼내서
- 그 interaction의 request를 실제 Provider에 보내고
- response를 계약과 비교한다

그래서 pact file 안에 여러 API가 있어도  
Provider는 자연스럽게  
**자기가 처리할 수 있는 요청만 검증**하게 된다.

API를 따로 구분하는 로직은 없다.  
interaction의 request 자체가 식별자 역할을 한다.

## @TestTemplate이 필요한 이유

Pact 테스트는

- 테스트 메서드 기준 실행이 아니라
- interaction 기준 실행

이 구조다.

interaction 개수는  
테스트 코드가 아니라 pact 정의에 따라 달라진다.

그래서 실행 횟수가 고정된 `@Test`가 아니라  
실행 계획을 외부에서 제공하는 `@TestTemplate`을 사용한다.
