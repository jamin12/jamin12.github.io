---
layout: post
title: "기술 선정"
date: 2025-12-18 14:20:00 +0900
categories: [기타, 러너스하이2, 주제1]
tags: [cdc]
---

## 여러가지 검증방식

검증 방식들을 찾아보니 몇 갈래로 나뉘어 보였다. 내가 봤던 건 크게 SCC, Pact, OpenAPI diff 같은 것들이었다.

처음에는 전부 비슷한 역할을 하는 줄 알았다. 그런데 자료를 조금 더 읽다 보니, 얘네는 같은 문제를 다른 위치에서 잡는 도구들이었다. 어떤 건 스펙 문서를 비교하고, 어떤 건 계약으로 테스트를 만들고, 어떤 건 소비자가 기대하는 형태를 기준으로 제공자를 검증한다는 식이었다.

OpenAPI diff는 old 스펙과 new 스펙을 비교해서 변경점을 뽑아내는 방식이었다. 그래서 “무엇이 바뀌었는지”는 잘 드러났다. 다만 다른 서비스가 그 API를 실제로 어떻게 쓰는지까지는 알 수 없다. 내가 겪었던 건 “A가 의존하던 응답 형태가 깨졌는데 사전에 감지하지 못했다”는 쪽이었고, 스펙 비교만으로는 그 지점과 연결이 약했다는 판단이 들었다.

그래서 계약 기반 검증 쪽(SCC, Pact)을 더 보게 됐다.

---

## Consumer 기준 / Producer 기준이라는 말이 계속 나왔고, 그게 결정 포인트가 됐다

CDC를 검색하다 보면 ‘Consumer-driven’, ‘Producer-driven’이라는 분류가 계속 나온다. SCC 예제랑 Pact 예제를 몇 개씩 보다 보니 분류가 구조 차이라는 게 보였다.

내가 정리한 기준은 이렇다.

- Consumer 기준은 “서버 B가 실제로 이렇게 쓰고 있다”가 계약의 출발점이다.
- Producer 기준은 “서버 A가 이렇게 제공한다”가 계약의 출발점이다.

여기서 내가 중요하게 본 건 “누가 계약을 소유하느냐”가 아니라, 변경이 발생했을 때 **어디에서 깨짐이 드러나느냐**였다.

---

## SCC(Spring Cloud Contract)

SCC 쪽 예제를 보면 보통 Producer(서버 A) 레포에 contract 파일이 있다. 그리고 그 contract로 테스트가 생성되고, 서버 A의 CI에서 그 테스트가 돈다.

이 흐름을 보고 처음 든 생각은 “이건 결국 서버 A가 자기 API를 자기 기준으로 검증하는 거 아닌가”였다. 그래서 “왜 굳이 이걸 도입하지?”라는 의문이 생겼다.

조금 더 자료를 찾아보니, SCC를 쓰는 이유로 반복되는 말이 있었다.

- 문서와 구현이 달라지는 걸 막는다
- 인터페이스를 고정한다
- 내부 구현을 바꿔도 외부 계약이 유지되는지 확인한다

이걸 보고 든 생각은, SCC가 해결하려는 문제는 내가 겪었던 문제와 결이 다르다는 거였다.

내가 겪은 문제는 “서버 A가 바뀌었을 때 서버 B가 깨진다”인데, SCC가 강하게 잡는 건 “서버 A가 정의한 규격이 서버 A 구현에서 지켜진다” 쪽이다. 둘이 아예 무관하진 않지만, 내 관점에서는 한 단계가 빠져 있었다.

SCC를 보다 보면 Consumer(서버 B) 쪽에서 `@AutoConfigureStubRunner`를 붙인 테스트가 같이 나온다. 서버 A의 stubs를 띄워서 서버 B의 로직을 검증하는 형태다.

이걸 봤을 때 처음 든 생각은 “그러면 서버 B도 테스트되는 거 아닌가”였다. 내가 원한 것도 결국 서버 B가 깨지는 걸 빨리 감지하는 거였으니까.

그래서 이 방식이 실제로 무엇을 보장하는지 다시 생각해봤다.

- StubRunner 테스트는 서버 B가 “서버 A의 stub이 이렇게 온다고 가정했을 때” 내 로직이 동작하는지를 본다.
- 여기서 서버 B는 검증되지만, 서버 A의 구현은 검증 대상이 아니다.
- 서버 A가 변경했을 때 문제가 생기면, 서버 B가 새 stub을 당겨와서 테스트를 돌리는 타이밍에야 깨짐이 보일 수 있다.

결국 이 방식은 “서버 B가 서버 A가 제공한 규격에 맞춰가는지”를 확인하는 성격이 강했다. 내가 원한 건 “서버 A가 바꿀 때 이미 깨짐이 드러나는지”였는데, 이건 서버 B가 갱신을 따라가야 보이는 구조였다.

여기에서 ‘Producer 기준’이라는 말이 왜 붙는지 납득이 됐다. 계약의 출발이 서버 A 쪽에 있고, 서버 B는 그 산출물(stub)을 소비하는 흐름이었다.

---

## ‘바로 알아차린다’의 의미를 다시 정리하게 됐다

중간에 스스로 헷갈렸던 부분이 “바로 알아차린다”였다.

- 소비자(서버 B)가 바로 알아차린다: 서버 B의 CI에서 즉시 실패한다
- 시스템이 바로 알아차린다: 제공자(서버 A)가 배포하기 전에 “누군가 깨진다”가 드러난다

내가 진짜 원한 건 두 번째였다. 서버 B가 런타임에서 터져서 알기 전에, 최소한 서버 A의 배포 단계에서 위험이 드러났으면 했다.

이 기준으로 보면 Consumer 기준 CDC(예: Pact)가 설명하는 흐름이 더 직관적으로 맞았다.

- 소비자(서버 B)가 계약을 만든다
- 제공자(서버 A)가 그 계약을 검증한다
- 서버 A가 변경하면 서버 A의 CI에서 깨짐이 보인다

이건 “서버 B가 바로 알게 된다”라기보다는, “서버 A가 바꾸는 순간 서버 B의 영향이 노출된다”에 가까웠다. 내가 찾던 건 이쪽이었다.

---

## 현재까지의 판단

지금까지 본 자료와 예제 기준으로는 이렇게 정리된다.

- SCC는 Producer(서버 A)가 자신의 규격을 고정하고, 문서/구현 불일치를 줄이는 목적에서는 의미가 있다.
- 하지만 “서버 A의 변경이 서버 B를 깨뜨리는지”를 서버 A 단계에서 잡는 목적에는 구조적으로 빈틈이 있다.
- 내가 겪었던 문제(서버 A의 변경이 서버 B를 깨뜨림)를 기준으로 보면, Consumer 기준 계약을 Producer가 검증하는 흐름이 더 맞아 보였다.

그래서 이 기준에 따라 Pact를 써보기로 했다. 아직 도입해서 운영까지 굴린 상태는 아니다. 계약을 어떤 단위로 만들지, 유지 비용이 어느 정도인지, 서비스가 늘어나면 관리가 어떻게 되는지는 직접 부딪혀 봐야 한다.

## 참고

{% include link-preview.html url="https://godekdls.github.io/Spring%20Cloud%20Contract/getting-started/" title="Spring Cloud Contract" %}

{% include link-preview.html url="https://dius.com.au/2016/02/03/pact-101-getting-started-with-pact-and-consumer-driven-contract-testing/" title="Pact 101: Getting started with Pact and Consumer Driven Contract Testing" %}