---
layout: post
title: "Grafana TLS 연결 문제 해결"
date: 2025-12-28
categories: [기타, 러너스하이2, 주제2]
tags: [러너스하이2_주제2]
---


## 이 글이 다루는 상황

사설 OpenSSL로 인증서를 만들어 Istio Ingress Gateway에 적용했다.

내부 개발자만 쓰는거라 간단한 tls 설정만하고 안전하지 않음으로 이동을 사용중이였는데
Grafana은 “안전하지 않음으로 이동” 같은 예외 버튼이 아예 없었다.

문제는 “TLS 설정이 안 됨”이 아니라, 브라우저가 **신뢰 검증을 통과하지 못한 것**이었다.
그리고 HSTS가 켜져 있으면, 그 실패를 “예외로 진행”하는 경로가 차단된다.

{% include link-preview.html url="https://jamin12.github.io/개념 정리/network/2025-12-28-tls/" %}

## 1. HTTPS에서 브라우저가 확인하는 것은 “서버”가 아니다

브라우저가 HTTPS로 접속하면 서버가 인증서를 보내는데, 브라우저가 판단하는 것은 이런 질문이다.

* 이 인증서는 누가 발급했나(Issuer)?
* 그 발급자는 내가 신뢰하는가(Trust Store)?
* 이 인증서가 지금 접속한 도메인에 대해 유효한가(SAN)?

즉 브라우저는 “서버를 믿는 것”이 아니라, **서버를 보증하는 발급자를 믿는다.**
이 구조 때문에, 서버 인증서를 만들었다고 끝이 아니라 “발급자 신뢰”가 완성되어야 한다.

## 2. HSTS가 있으면 “예외 버튼”이 사라진다

일반적인 인증서 오류는 브라우저에서 “안전하지 않음으로 이동” 같은 예외 경로가 남아 있는 경우가 있다.
하지만 HSTS가 걸리면 다음이 동시에 발생한다.

* HTTP로 내려가는 우회가 차단된다(무조건 HTTPS).
* 인증서 오류를 예외로 진행하는 것도 차단된다.

그래서 같은 종류의 오류라도,

* 어떤 도메인은 예외 버튼이 있고
* 어떤 도메인은 예외 버튼이 없다

처럼 보일 수 있다.
예외 버튼이 없던 Grafana는 브라우저가 해당 도메인에 대해 HSTS 상태로 판단했기 때문이다.

## 3. 왜 “CA를 만들고” “서버 인증서를 발급”해야 했나

결론부터 말하면

서버 인증서를 신뢰시키려면 서버 인증서를 설치하는 게 아니라, **그 인증서를 서명한 CA를 신뢰시켜야 한다.**

“서버 인증서(crt)를 만들어 서버에 적용하면 된다.” 그런데 self-signed 서버 인증서는 대체로 다음 형태다.

* 서버가 자기 자신에게 서명함(Issuer = 자기 자신)

브라우저 입장에서는 이렇게 보인다.

* “이 서버가 스스로 만든 신분증을 스스로 승인했다.”

HSTS가 있으면 이런 형태는 거의 막힌다.
그래서 서버 자체가 아니라, **서버를 승인할 발급자(CA)** 를 따로 세우는 방식이 필요하다.

* 루트 CA가 있고
* 그 CA가 서버 인증서를 서명한다
* 클라이언트는 루트 CA를 신뢰 목록에 넣는다
* 그러면 그 CA가 서명한 서버 인증서는 자동으로 신뢰된다

## 5. 서버 키를 왜 만들었나

서버 인증서가 “신분증 문서”라면, 서버 개인키는 “그 신분증의 주인임을 증명하는 비밀키”이다.

브라우저는 TLS 핸드셰이크에서 본질적으로 이런 걸 확인한다.

* “너 정말 이 인증서에 들어있는 공개키의 개인키를 가지고 있어?”

서버는 개인키를 보내지 않는다.
대신 개인키로만 가능한 연산(서명/복호화 계열)을 수행해서 “가지고 있음”을 증명한다.

그래서 서버가 TLS 서버로 동작하려면 반드시 서버 개인키가 필요하다.

* `noo-monitoring.key` 는 “HTTPS 서버”가 들고 있어야 하는 개인키다.

## 6. CSR은 왜 필요한가

CSR은 “인증서 발급 요청서”인데, 더 정확히는 이렇게 보는 게 맞다.

CSR은
“이 공개키의 소유자가 이 도메인에 대한 인증서를 요청한다”는 **서명된 요청 문서**다.

CSR 생성 명령은 이런 의미를 가진다.

```bash
openssl req -new \
  -key noo-monitoring.key \
  -out noo-monitoring.csr \
  -subj "/CN=noo.grafana.com"
```

* CSR 파일 안에는 서버 **공개키**가 들어간다.
* CSR 파일 안에는 요청 정보(CN 등)가 들어간다.
* CSR 파일 안에는 “이 요청이 공개키의 소유자에 의해 만들어졌다”는 **서명**이 들어간다.
* CSR 파일 안에는 서버 **개인키는 들어가지 않는다.**

CSR은 “내가 가진 공개키를 인증서에 넣고, 이 도메인에 대해 보증해 달라”는 문서다.

> 개인키만 있으면 공개키를 알 수있다.
>
> 개인키 → 공개키: 가능
>
> 공개키 → 개인키: 현실적으로 불가능

## 7. SAN은 무엇이고, 왜 CN으로는 안 됐나

CN(Common Name)은 “대표 이름”처럼 보이지만, 현대 브라우저의 도메인 검증 기준은 SAN이다.

SAN(Subject Alternative Name)은
“이 인증서가 유효한 도메인 목록”이다.

브라우저는 접속할 때 다음을 한다.

* 접속한 호스트: `noo.grafana.com`
* 인증서의 SAN 목록을 읽음
* SAN에 `noo.grafana.com`이 있나?
  * 있으면 통과
  * 없으면 실패

CN만 있고 SAN이 없으면
브라우저는 “도메인 일치”를 인정하지 않는다.

```bash
cat > noo-monitoring.ext <<'EOF'
subjectAltName=DNS:noo.grafana.com,DNS:noo.prom.com
extendedKeyUsage=serverAuth
EOF
```

이 파일은 “이 서버 인증서는 이 도메인들에 대해 유효해야 한다”는 정책을 명시하는 역할을 했다.

## 8. CA가 CSR을 서명한다는 건 무슨 뜻인가

여기서 “서명”이 두 번 등장한다.

* CSR 생성 시 서명: 서버 개인키로 CSR 요청서를 서명함(소유 증명)
* 서버 인증서 발급 시 서명: CA 개인키로 서버 인증서를 서명함(보증)

동일한 “서명”이지만 역할은 완전히 다르다.

서버 인증서 발급 명령은 이 의미다.

```bash
openssl x509 -req \
  -in noo-monitoring.csr \
  -CA noo-root-ca.crt \
  -CAkey noo-root-ca.key \
  -CAcreateserial \
  -out noo-monitoring.crt \
  -days 825 -sha256 \
  -extfile noo-monitoring.ext
```

이 작업으로 생성된 `noo-monitoring.crt`는 단순한 공개키 묶음이 아니라,

* 서버 공개키를 포함하고
* CN/SAN 등 신원 정보를 포함하고
* “이 조합을 CA가 보증한다”는 CA 서명을 포함한 문서가 된다

여기서 `crt`는 공개키 그 자체가 아니다.

* 공개키: 암호 연산에 쓰이는 키 재료
* 인증서(crt): 공개키 + 신원 정보 + 발급자 정보 + 발급자 서명

인증서는 “공개키가 누구 것인지”를 설명하는 문서다.

## 9. Windows에 CA를 등록하면 왜 HSTS에서도 통과하나

브라우저의 최종 판단은 결국 “신뢰 체인”이다.

* 서버 인증서의 Issuer가 누구인지 확인
* 그 Issuer의 공개키가 Trust Store에 있는지 확인
* 그 공개키로 서버 인증서의 서명이 검증되는지 확인

Windows Root Store에 `noo-root-ca.crt`를 넣었다.

```powershell
certutil -addstore -f "Root" ...\noo-root-ca.crt
```

“이 CA를 공인 CA처럼 취급해줘”에 가깝다.

그래서 브라우저 입장에서는 이제 이렇게 된다.

* 서버 인증서 Issuer = `noo-local-ca`
* Trust Store에 `noo-local-ca` 있음
* 서명 검증 OK
* SAN에 도메인 있음

## 10. 전체 과정

1. 서버는 키를 가진다(소유 증명)
2. CA는 서버를 보증한다(서명)
3. 클라이언트는 CA를 신뢰 목록에 올린다(루트 신뢰)
4. 브라우저는 SAN으로 도메인을 확인한다(도메인 검증)

* `noo-root-ca.key` : 발급자 개인키(서명용)
* `noo-root-ca.crt` : 발급자 공개키(클라이언트 신뢰 등록용)
* `noo-monitoring.key` : 서버 개인키(핸드셰이크 증명용)
* `noo-monitoring.csr` : 공개키 + 요청 정보 + 서버 서명(발급 요청서)
* `noo-monitoring.ext` : SAN(도메인 유효 범위)
* `noo-monitoring.crt` : 서버 인증서(서버 공개키 + CA 보증 서명)

이렇게 역할이 겹치지 않게 분리되어 있기 때문에, 단계가 많아 보이지만 구조는 일관된다.
