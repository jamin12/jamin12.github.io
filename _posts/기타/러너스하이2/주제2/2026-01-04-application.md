---
layout: post
title: "Application"
date: 2026-01-04
categories: [기타, 러너스하이2, 주제2]
tags: [러너스하이2_주제2]
---

## Heap / OldGen 사용량

**Heap**은 JVM에서 객체가 생성되고 관리되는 메모리 영역이다. 요청 처리 과정에서 생성되는 메서드 호출, DTO, 컬렉션, 임시 객체 등의 대부분이 이곳에 할당된다. GC(Garbage Collection)를 통해 더 이상 참조되지 않는 객체는 회수된다. 즉, Heap 지표는 애플리케이션이 현재 얼마나 많은 객체를 사용하고 있는지를 나타낸다.

**OldGen(Old Generation)** 은 Heap 내부에서 오래 살아남은 객체들이 이동하는 영역이다. 여러 번의 GC에도 살아남은 캐시, 싱글톤, 장기 세션 정보 등이 주로 위치한다. 이곳의 객체는 회수 비용이 크고 회수가 잘 되지 않는 특징이 있다. 따라서 OldGen 지표는 장기간 유지되는 객체가 얼마나 쌓여 있는지를 보여준다.

Heap 사용량은 트래픽에 따라 변동하는 것이 정상이나, OldGen은 일정 수준에서 안정적으로 유지되어야 한다. OldGen이 계속 증가한다면 객체가 해제되지 않고 있다는 의미다.

지표의 패턴은 다음과 같이 해석한다.

* **Heap 증가 후 GC로 감소**: 정상적인 객체 생성 및 회수 패턴이다.
* **OldGen 지속적 우상향**: 장기 생존 객체가 누적되고 있음을 의미한다. 캐시 미정리, Static 참조, 리스너 누수 등으로 인한 메모리 누수를 의심해야 한다.
* **Heap은 회수되나 OldGen은 유지**: 단기 객체는 회수되지만 장기 객체가 고정적으로 남아있는 상태로, 구조적 누수 가능성이 있다.
* **Heap/OldGen 모두 상한 유지**: 메모리 여유가 없는 상태다. Full GC가 빈번해지고 응답 지연이나 OOM(Out Of Memory) 발생 위험이 있다.

![Heap/OldGen Graph](/assets/imgs/posts/기타/러너스하이/주제2/application/image1.png)

## Heap 사용률 (%)

JVM이 할당받은 최대 힙 크기(Heap Max) 대비 현재 사용 중인 메모리의 비율을 나타낸다. (Heap Used ÷ Heap Max × 100)

이 지표를 통해 JVM의 메모리 상태가 안전한지, 위험 수위에 근접했는지 판단할 수 있다.

* **50%**: 힙 여유가 충분한 안정적인 상태다.
* **70%**: GC 부담이 시작되는 구간이다. 70~85% 구간이 지속되면 GC가 자주 발생하여 성능 저하가 일어날 수 있다.
* **85%**: 메모리 압박 상태다. Full GC 가능성이 증가하고 응답 지연이나 타임아웃이 발생할 수 있다.
* **95% 이상**: OOM 위험 구간이다. 반복적으로 접근한다면 즉각적인 조치가 필요하다.

![Heap Usage Graph](/assets/imgs/posts/기타/러너스하이/주제2/application/image2.png)

## Thread 수

애플리케이션이 동시에 작업을 얼마나 처리하고 있는지 보여주는 지표다. CPU 사용률이나 RPS보다 먼저 지연과 장애의 전조로 나타나는 경향이 있다.

* **Total Threads**: JVM에 존재하는 전체 스레드 수다. 요청 처리 스레드와 비동기/백그라운드 스레드를 모두 포함한다. 이 값이 계속 증가하면 스레드가 해제되지 않고 쌓이고 있음을 의미한다.
* **Runnable Threads**: CPU를 점유하여 실행 가능한 상태인 스레드 수다. 이 값이 높으면 CPU 경합이 심해졌음을 뜻한다.
* **Blocked / Waiting Threads**: 락(Lock) 대기, DB I/O, 외부 API 응답 대기 등으로 멈춰 있는 스레드 수다.

패턴은 다음과 같이 해석한다.

* **Total Threads 지속 증가**: 처리 속도보다 유입 속도가 빠르거나 스레드 풀이 비워지지 않는 상태다. 비동기 작업 적체나 요청 타임아웃 누적을 의심할 수 있다.
* **Blocked / Waiting Threads 급증**: DB 쿼리 지연, 외부 API 지연, 락 경쟁 등이 발생했음을 나타낸다. 타임아웃이나 5xx 오류로 이어질 수 있는 위험한 신호다.
* **Runnable Threads 급증**: CPU가 포화 상태에 가까워졌음을 의미한다. GC나 컨텍스트 스위칭 비용이 증가했거나 처리량 대비 스레드 수가 과다할 수 있다.
* **Runnable은 낮고 Blocked/Waiting만 높음**: CPU는 여유가 있으나 I/O 작업에 묶여 있는 상태다. 스케일아웃으로 해결되지 않는 구조적 병목일 가능성이 높다.

해석 시 Thread 수가 증가하면서 HTTP P95/P99가 같이 오르면 요청이 스레드에서 대기 중인 것이고, Blocked/Waiting과 DB Latency가 같이 오르면 DB 병목이 확실하다.

![Thread Count Graph](/assets/imgs/posts/기타/러너스하이/주제2/application/image3.png)

## GC Pause 시간 / 빈도

GC Pause는 애플리케이션이 GC로 인해 실제로 멈춘 시간과 빈도를 나타낸다. CPU나 Heap 지표보다 사용자 체감 성능 저하와 가장 직결되는 지표다.

값은 최근 5분간의 평균을 보여준다. 예를 들어 Pause 시간이 0.0456 sec/s라면 1초 중 약 0.0456초(4.56%)가 멈췄다는 의미이며, 빈도가 0.0148 ops/s라면 5분(300초) 동안 약 4.4회 발생했음을 뜻한다.

패턴별로 다음과 같이 해석한다.

* **Pause 시간 ↑ + 빈도 ↑**: GC가 명확한 성능 병목인 상태다. Heap 압박이나 객체 생명주기 설계에 문제가 있을 가능성이 크며, 전체적인 응답 속도와 처리량이 저하된다.
* **Pause 시간 ↓ + 빈도 ↑**: 짧은 Minor GC가 과도하게 발생하는 상태다. 객체 생성이 너무 잦거나 Eden 영역이 작을 수 있다.
* **Pause 시간 ↑ + 빈도 ↓**: Full GC 또는 Old GC가 발생했을 가능성이 높다. OldGen 누수나 큰 객체 할당을 의심해야 하며, 순간적인 긴 멈춤으로 타임아웃이 발생할 수 있다.
* **시간과 빈도 모두 낮음**: GC는 성능 문제의 원인이 아니다. DB, 외부 호출, 네트워크 등 다른 요인을 살펴봐야 한다.

GC Pause가 증가하면서 HTTP P95/P99가 높아지면 GC로 인한 처리 지연이 발생한 것이고, RPS가 정체된다면 처리량이 GC에 막혀 있는 상태다. OldGen이 지속적으로 증가하면서 Pause 시간이 길어진다면 메모리 누수 가능성이 매우 높다.

![GC Pause Graph](/assets/imgs/posts/기타/러너스하이/주제2/application/image4.png)

## 서버 CPU 사용량

애플리케이션이 실제로 연산을 얼마나 수행하고 있는지를 보여준다. 지연이나 오류 발생 시 이것이 계산 병목인지 다른 자원의 병목인지 판단하는 기준이 된다. Spring Boot JVM 프로세스가 전체 서버 CPU에서 차지하는 비율을 나타내며, 계산 로직, 직렬화, 암호화, GC 비용 등이 포함된다.

해석 패턴은 다음과 같다.

* **Process CPU 지속 상승**: 애플리케이션의 연산 부하가 증가했음을 의미한다. 복잡한 비즈니스 로직, 비용 높은 직렬화, 혹은 GC 비용 증가가 원인일 수 있다.
* **CPU ↑ + HTTP P95/P99 ↑**: 연산 병목으로 인해 요청 처리가 지연되고 있다.
* **CPU ↑ + Thread(Runnable) ↑**: CPU 경합과 컨텍스트 스위칭이 증가하고 있다.
* **CPU 낮음 + Thread(Blocked/Waiting) ↑**: CPU가 아닌 I/O 병목(DB, 외부 API 등)이 원인이다.
* **CPU ↑ + GC Pause ↑**: GC 처리에 CPU 자원이 소모되고 있음을 나타낸다.

![CPU Usage Graph](/assets/imgs/posts/기타/러너스하이/주제2/application/image5.png)
